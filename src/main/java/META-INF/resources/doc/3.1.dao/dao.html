<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<link type="text/css" href="../css/document.css" rel="stylesheet" />
		<title>DAOパッケージ</title>
	</head>
	<body>
		<h1><span>3.1.</span>Table,Query,Dao</h1>
		<p>
			この章ではdataforms.daoパッケージのTable,Query,Daoクラスについて解説していきます。
			Tableクラスはテータベース中のテーブルの構造を定義します。
			QueryクラスはSQLのselect文に対応するクラスです。
			複数のテーブルクラスを結合した問合せクラスを作成することができるようになっています。
			DaoクラスはTableクラスのレコード追加・更新・削除、Queryクラスで定義した問合せを実行する機能を持っています。
			dataforms.daoパッケージは複数のデータベースサーバ(Apache Derby,PostgreSQL,MySQL,Oracle)に対応しています。
			各データベースのサーバのSQLには方言があり、直接データベースをアクセスする場合その文法の違いを考慮してSQLを記述する必要がありました。
			dataforms2.jarでは、これらのJavaクラスを使用することによって、データベースに依存するコードを排除することができます。
			実際「単体テストまでは環境構築が簡単なApache Derbyで作業し、結合テスト以降はPostgreSQLサーバを用意して実行」という開発を問題なく進めた実績があります。
		</p>
		<h2>Tomcatのデータベース接続設定</h2>
		<p>
			テータベースの接続設定はTomcat等のアプリケーションサーバ側で行います。
			Tomcat9を例に設定のポイントを説明します。
		</p>
		<h3>データベースの接続設定の記述場所</h3>
		<p>
			df2blank_xxx.warをインポートしたプロジェクトでは、WebContent/META-INF/content.xmlというファイルが存在しています。
			このファイルにデータベースの接続設定が入っています。
			WebContent/META-INF/content.xmlはwarファイルの中に含まれているファイルです。
			そのためWebアプリケーションにDBへの接続設定を含めてリリースする場合に使用します。
			runwar等を使用してスタンドアロンアプリケーションのように使用する場合、
			WebContent/META-INF/content.xmlを使用します。
		</p>
		<p>
			Tomcat9ではデータベースの接続設定を$CATALINA_HOME/conf/context.xmlにも記述することができます。
			(Eclipse上のTomcatの場合"Servers/ローカルホスト の Tomcat9 (Java11)-config/context.xml"がこれに当たります。)
			WebContent/META-INF/content.xmlデータベースの接続設定を削除し、$CATALINA_HOME/conf/context.xmlにデータベース接続設定を移動しても同様に動作します。
			この状態で*.warファイルを作成すると、*.warファイル中に接続設定は存在しないため、Tomcatのデータベース接続設定が使用されます。
			Eclipse上のTomcatはテスト用のデータベースに接続し、本番用サーバ上のTomcatには本番用データベースに接続するように設定しておきます。
			こうしておくと、Eclipseで*.warファイルを作成し本番用サーバの$CATALINA_HOME/webappsにコピーするだけで、本番環境へのデプロイが完了します。
		</p>
		<h3>データベース接続設定の記述内容</h3>
		<p>
			df2blank_xxx.war中のMETA-INF/context.xmlを以下に示します。
		</p>
		<div class="filecaption">context.xmlの内容</div>
		<div class="wrappre">
			<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE Context&gt;
&lt;Context&gt;
	&lt;!--
		&#12513;&#12540;&#12523;&#36865;&#20449;&#27231;&#33021;&#12434;&#20351;&#29992;&#12377;&#12427;&#22580;&#21512;SMTP&#12469;&#12540;&#12496;&#12398;&#24773;&#22577;&#12434;&#36969;&#20999;&#12395;&#35373;&#23450;&#12375;&#12390;&#12367;&#12384;&#12373;&#12356;&#12290;
	 --&gt;
	&lt;!--
	&lt;Resource name=&quot;mail/Session&quot; auth=&quot;Container&quot; type=&quot;javax.mail.Session&quot;
		mail.smtp.host=&quot;localhost&quot; mail.smtp.port=&quot;25&quot; /&gt;
	--&gt;
	&lt;!--
		&#32068;&#12415;&#36796;&#12415;Apache derby&#29992;&#12398;&#25509;&#32154;&#35373;&#23450;
		Apache derby&#12398;JDBC&#12489;&#12521;&#12452;&#12496;&#12399;&#21046;&#32004;&#21517;&#31216;&#12434;&#21462;&#24471;&#12377;&#12427;API&#12364;&#12354;&#12427;&#12383;&#12417;
		duplicateErrorMessage&#12392;foreignKeyErrorMessage&#12398;&#35373;&#23450;&#12399;&#19981;&#35201;&#12290;
	 --&gt;
	&lt;Resource auth=&quot;Container&quot;
		driverClassName=&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;
		name=&quot;jdbc/dfdb&quot; type=&quot;javax.sql.DataSource&quot;
		url=&quot;jdbc:derby:./javadb/blankdb;create=true&quot;
		username=&quot;&quot; password=&quot;&quot; /&gt;
	&lt;!--
		Apache derby&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12469;&#12540;&#12496;&#29992;&#12398;&#25509;&#32154;&#35373;&#23450;
		Apache derby&#12398;JDBC&#12489;&#12521;&#12452;&#12496;&#12399;&#21046;&#32004;&#21517;&#31216;&#12434;&#21462;&#24471;&#12377;&#12427;API&#12364;&#12354;&#12427;&#12383;&#12417;
		duplicateErrorMessage&#12392;foreignKeyErrorMessage&#12398;&#35373;&#23450;&#12399;&#19981;&#35201;&#12290;
	--&gt;
	&lt;!--
	&lt;Resource auth=&quot;Container&quot; driverClassName=&quot;org.apache.derby.jdbc.ClientDriver&quot;
		maxActive=&quot;8&quot; maxIdle=&quot;4&quot; name=&quot;jdbc/dfdb&quot; type=&quot;javax.sql.DataSource&quot;
		url=&quot;jdbc:derby://localhost:1527/javadb/blankdb;create=true&quot; username=&quot;APP&quot;
		password=&quot;password&quot; /&gt;
	--&gt;

	&lt;!--
		PostgreSQL&#29992;&#12398;&#25509;&#32154;&#35373;&#23450;
		&#21046;&#32004;&#36949;&#21453;&#12398;&#22580;&#21512;&#12289;&#21046;&#32004;&#21517;&#12399;&#12456;&#12521;&#12540;&#12513;&#12483;&#12475;&#12540;&#12472;&#12363;&#12425;&#21462;&#24471;&#12377;&#12427;&#12398;&#12391;&#12289;
		&#19968;&#24847;&#21046;&#32004;&#21517;&#21462;&#24471;&#29992;&#12398;&#27491;&#35215;&#34920;&#29694;&#12434;duplicateErrorMessage&#12289;
		&#22806;&#37096;&#12461;&#12540;&#21046;&#32004;&#29992;&#21517;&#21462;&#24471;&#29992;&#12398;&#27491;&#35215;&#34920;&#29694;&#12434;foreignKeyErrorMessage&#12395;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;
	 --&gt;
	&lt;!--
	&lt;Resource name=&quot;jdbc/dfdb&quot; type=&quot;javax.sql.DataSource&quot;
		auth=&quot;Container&quot; driverClassName=&quot;org.postgresql.Driver&quot;
		url=&quot;jdbc:postgresql://192.168.56.102:5432/blankdb&quot; username=&quot;postgres&quot;
		password=&quot;&quot; /&gt;
	&lt;Environment name=&quot;duplicateErrorMessage&quot; value=&quot;&#19968;&#24847;&#24615;&#21046;&#32004;&quot;(.+?)&quot;&#12395;&#36949;&#21453;&quot; type=&quot;java.lang.String&quot; override=&quot;false&quot;/&gt;
	&lt;Environment name=&quot;foreignKeyErrorMessage&quot; value=&quot;&#22806;&#37096;&#12461;&#12540;&#21046;&#32004;&quot;(.+?)&quot;&#12395;&#36949;&#21453;&quot; type=&quot;java.lang.String&quot; override=&quot;false&quot;/&gt;
	--&gt;

	&lt;!--
		MariaDB&#29992;&#25509;&#32154;&#35373;&#23450;
		MariaDB&#29992;&#12398;jdbc&#12489;&#12521;&#12452;&#12496;&#12540;&#12434;&#20351;&#29992;&#12377;&#12427;&#22580;&#21512;&#12398;&#35373;&#23450;&#12391;&#12377;&#12290;
		&#21046;&#32004;&#36949;&#21453;&#12398;&#22580;&#21512;&#12289;&#21046;&#32004;&#21517;&#12399;&#12456;&#12521;&#12540;&#12513;&#12483;&#12475;&#12540;&#12472;&#12363;&#12425;&#21462;&#24471;&#12377;&#12427;&#12398;&#12391;&#12289;
		&#19968;&#24847;&#21046;&#32004;&#21517;&#21462;&#24471;&#29992;&#12398;&#27491;&#35215;&#34920;&#29694;&#12434;duplicateErrorMessage&#12289;
		&#22806;&#37096;&#12461;&#12540;&#21046;&#32004;&#29992;&#21517;&#21462;&#24471;&#29992;&#12398;&#27491;&#35215;&#34920;&#29694;&#12434;foreignKeyErrorMessage&#12395;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;
	 --&gt;
	&lt;!--
	&lt;Resource name=&quot;jdbc/dfdb&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot;
		username=&quot;dfuser&quot; password=&quot;password&quot; driverClassName=&quot;org.mariadb.jdbc.Driver&quot;
		url=&quot;jdbc:mysql://192.168.56.102/blankdb?useOldAliasMetadataBehavior=true&quot; /&gt;
	&lt;Environment name=&quot;duplicateErrorMessage&quot; value=&quot;for key '(.+?)'$&quot; type=&quot;java.lang.String&quot; override=&quot;false&quot;/&gt;
	&lt;Environment name=&quot;foreignKeyErrorMessage&quot; value=&quot;CONSTRAINT `(.+?)` FOREIGN KEY&quot; type=&quot;java.lang.String&quot; override=&quot;false&quot;/&gt;
	--&gt;

	&lt;!--
		MySQL&#29992;&#25509;&#32154;&#35373;&#23450;
		MySQL&#29992;&#12398;jdbc&#12489;&#12521;&#12452;&#12496;&#12540;&#12434;&#20351;&#29992;&#12377;&#12427;&#22580;&#21512;&#12398;&#35373;&#23450;&#12391;&#12377;&#12290;
		&#21046;&#32004;&#36949;&#21453;&#12398;&#22580;&#21512;&#12289;&#21046;&#32004;&#21517;&#12399;&#12456;&#12521;&#12540;&#12513;&#12483;&#12475;&#12540;&#12472;&#12363;&#12425;&#21462;&#24471;&#12377;&#12427;&#12398;&#12391;&#12289;
		&#19968;&#24847;&#21046;&#32004;&#21517;&#21462;&#24471;&#29992;&#12398;&#27491;&#35215;&#34920;&#29694;&#12434;duplicateErrorMessage&#12289;
		&#22806;&#37096;&#12461;&#12540;&#21046;&#32004;&#29992;&#21517;&#21462;&#24471;&#29992;&#12398;&#27491;&#35215;&#34920;&#29694;&#12434;foreignKeyErrorMessage&#12395;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;
	--&gt;
	&lt;!--
	&lt;Resource name=&quot;jdbc/dfdb&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot;
		username=&quot;dfuser&quot; password=&quot;password&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot;
		url=&quot;jdbc:mysql://192.168.56.102/blankdb?generateSimpleParameterMetadata=true&amp;useInformationSchema=true&amp;useOldAliasMetadataBehavior=true&amp;characterEncoding=utf8&quot; /&gt;
	&lt;Environment name=&quot;duplicateErrorMessage&quot; value=&quot;for key '(.+?)'$&quot; type=&quot;java.lang.String&quot; override=&quot;false&quot;/&gt;
	&lt;Environment name=&quot;foreignKeyErrorMessage&quot; value=&quot;CONSTRAINT `(.+?)` FOREIGN KEY&quot; type=&quot;java.lang.String&quot; override=&quot;false&quot;/&gt;
	--&gt;

	&lt;!--
		ORACLE&#29992;&#12398;&#25509;&#32154;&#35373;&#23450;
		&#21046;&#32004;&#36949;&#21453;&#12398;&#22580;&#21512;&#12289;&#21046;&#32004;&#21517;&#12399;&#12456;&#12521;&#12540;&#12513;&#12483;&#12475;&#12540;&#12472;&#12363;&#12425;&#21462;&#24471;&#12377;&#12427;&#12398;&#12391;&#12289;
		&#19968;&#24847;&#21046;&#32004;&#21517;&#21462;&#24471;&#29992;&#12398;&#27491;&#35215;&#34920;&#29694;&#12434;duplicateErrorMessage&#12289;
		&#22806;&#37096;&#12461;&#12540;&#21046;&#32004;&#29992;&#21517;&#21462;&#24471;&#29992;&#12398;&#27491;&#35215;&#34920;&#29694;&#12434;foreignKeyErrorMessage&#12395;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;
	--&gt;
	&lt;!--
	&lt;Resource name=&quot;jdbc/dfdb&quot; auth=&quot;Container&quot;
		type=&quot;javax.sql.DataSource&quot; driverClassName=&quot;oracle.jdbc.OracleDriver&quot;
		url=&quot;jdbc:oracle:thin:@192.168.56.102:1521:xe&quot;
		username=&quot;dfuser&quot; password=&quot;password&quot;/&gt;
	&lt;Environment name=&quot;duplicateErrorMessage&quot; value=&quot;constraint \(.+?\.(.+?)\) violated&quot; type=&quot;java.lang.String&quot; override=&quot;false&quot;/&gt;
	&lt;Environment name=&quot;foreignKeyErrorMessage&quot; value=&quot;constraint \(.+?\.(.+?)\) violated &quot; type=&quot;java.lang.String&quot; override=&quot;false&quot;/&gt;
	--&gt;
&lt;/Context&gt;
			</pre>
		</div>
		<p>
			デフォルト設定ではApache derbyの組み込みドライバの設定が有効になっており、
			PostgreSQL,MySQL(MariaDB),Oracleの設定例はコメントで記述されています。
			接続するデータベースに対応する接続設定を有効にしてください。
		</p>
		<p>
			Apache derbyのJDBCドライバは制約違反発生時の制約名称を取得するAPIを持っているため、追加設定は必要ありません。
			しかし、その他のJDBCドライバにはそのようなAPIがないため、エラーメッセージから制約名を取得するようになっています。
			そのため、duplicateErrorMessageに一意制約時のエラーメッセージのパターン、
			foreignKeyErrorMessageに外部制約違反時のエラーメッセージのパターンを記述する必要があります。
			このメッセージはOSの言語設定やDBサーバのバージョンによって異なる可能性があるため、
			制約名が取得できない場合は適切に変更する必要があります。
		</p>
		<h3>web.xmlの設定</h3>
		<p>
			context.xmlに記述したJNDIデータソースの名称は"jdbc/dfdb"となっています。
			これを変更した場合、WebContent/WEB-INF/web.xmlの以下の部分を修正する必要があります。
		</p>
		<div class="filecaption">web.xmlの内容</div>
		<div class="wrappre">
			<pre>
	&lt;!--
	JNDI&#12487;&#12540;&#12479;&#12477;&#12540;&#12473;&#12398;lookup&#12395;&#12399;jndi-prefix&#12392;data-source&#12434;&#32080;&#21512;&#12375;&#12383;&#25991;&#23383;&#21015;&#12391;&#34892;&#12356;&#12414;&#12377;&#12290;
	WebLogic&#12391;&#23455;&#34892;&#12377;&#12427;&#22580;&#21512;&#12399;jndi-prefix&#12395;&#12399;&#31354;&#30333;&#25991;&#23383;&#12434;&#25351;&#23450;&#12375;&#12390;&#12367;&#12384;&#12373;&#12356;&#12290;
	 --&gt;
	&lt;!-- JNDI&#12487;&#12540;&#12479;&#12477;&#12540;&#12473;&#12398;&#21069;&#12395;&#12388;&#12369;&#12427;&#25991;&#23383;&#21015; --&gt;
	&lt;context-param&gt;
		&lt;param-name&gt;jndi-prefix&lt;/param-name&gt;
		&lt;param-value&gt;java:/comp/env/&lt;/param-value&gt;
	&lt;/context-param&gt;
	&lt;!-- &#20351;&#29992;&#12377;&#12427;JNDI&#12487;&#12540;&#12479;&#12477;&#12540;&#12473;&#12434;&#25351;&#23450;&#12377;&#12427; --&gt;
	&lt;context-param&gt;
		&lt;param-name&gt;data-source&lt;/param-name&gt;
		&lt;param-value&gt;jdbc/dfdb&lt;/param-value&gt;
	&lt;/context-param&gt;
			</pre>
		</div>
		<h2>Tableクラス</h2>
		<h3>ツールで生成されたTableクラスの構造</h3>
		<p>
			開発ツールで作成されたテーブルクラスを以下に示します。
		</p>
		<div class="filecaption">開発ツールで作成したテーブルクラス</div>
		<div class="wrappre">
			<pre>
package sample.dao;

import java.util.Map;
import dataforms.dao.Table;
import sample.field.SampleIdField;
import sample.field.SampleTextField;
import sample.field.SampleNumericField;
import sample.field.SampleDateField;
import sample.field.SampleSelectField;


/**
 * &#12469;&#12531;&#12503;&#12523;&#12486;&#12540;&#12502;&#12523;&#12463;&#12521;&#12473;&#12290;
 *
 */
public class SampleTable extends Table {
	/**
	 * &#12467;&#12531;&#12473;&#12488;&#12521;&#12463;&#12479;&#12290;
	 */
	public SampleTable() {
		this.setAutoIncrementId(true);
		this.setComment(&quot;&#12469;&#12531;&#12503;&#12523;&#12486;&#12540;&#12502;&#12523;&quot;);
		this.addPkField(new SampleIdField()); //&#12524;&#12467;&#12540;&#12489;ID
		this.addField(new SampleTextField()); //&#12486;&#12461;&#12473;&#12488;
		this.addField(new SampleNumericField()); //&#25968;&#20516;
		this.addField(new SampleDateField()); //&#26085;&#20184;
		this.addField(new SampleSelectField()); //&#12469;&#12531;&#12503;&#12523;&#36984;&#25246;&#32930;
		this.addUpdateInfoFields();
	}

	@Override
	public String getJoinCondition(final Table joinTable, final String alias) {
		SampleTableRelation r = new SampleTableRelation(this);
		return r.getJoinCondition(joinTable, alias);
	}

	/**
	 * Entity&#25805;&#20316;&#12463;&#12521;&#12473;&#12391;&#12377;&#12290;
	 */
	public static class Entity extends dataforms.dao.Entity {
		/** &#12524;&#12467;&#12540;&#12489;ID&#12398;&#12501;&#12451;&#12540;&#12523;&#12489;ID&#12290; */
		public static final String ID_SAMPLE_ID = &quot;sampleId&quot;;
		/** &#12486;&#12461;&#12473;&#12488;&#12398;&#12501;&#12451;&#12540;&#12523;&#12489;ID&#12290; */
		public static final String ID_SAMPLE_TEXT = &quot;sampleText&quot;;
		/** &#25968;&#20516;&#12398;&#12501;&#12451;&#12540;&#12523;&#12489;ID&#12290; */
		public static final String ID_SAMPLE_NUMERIC = &quot;sampleNumeric&quot;;
		/** &#26085;&#20184;&#12398;&#12501;&#12451;&#12540;&#12523;&#12489;ID&#12290; */
		public static final String ID_SAMPLE_DATE = &quot;sampleDate&quot;;
		/** &#12469;&#12531;&#12503;&#12523;&#36984;&#25246;&#32930;&#12398;&#12501;&#12451;&#12540;&#12523;&#12489;ID&#12290; */
		public static final String ID_SAMPLE_SELECT = &quot;sampleSelect&quot;;

		/**
		 * &#12467;&#12531;&#12473;&#12488;&#12521;&#12463;&#12479;&#12290;
		 */
		public Entity() {

		}
		/**
		 * &#12467;&#12531;&#12473;&#12488;&#12521;&#12463;&#12479;&#12290;
		 * @param map &#25805;&#20316;&#23550;&#35937;&#12510;&#12483;&#12503;&#12290;
		 */
		public Entity(final Map&lt;String, Object&gt; map) {
			super(map);
		}
		/**
		 * &#12524;&#12467;&#12540;&#12489;ID&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
		 * @return &#12524;&#12467;&#12540;&#12489;ID&#12290;
		 */
		public java.lang.Long getSampleId() {
			return (java.lang.Long) this.getMap().get(Entity.ID_SAMPLE_ID);
		}

		/**
		 * &#12524;&#12467;&#12540;&#12489;ID&#12434;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;
		 * @param sampleId &#12524;&#12467;&#12540;&#12489;ID&#12290;
		 */
		public void setSampleId(final java.lang.Long sampleId) {
			this.getMap().put(Entity.ID_SAMPLE_ID, sampleId);
		}

		/**
		 * &#12486;&#12461;&#12473;&#12488;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
		 * @return &#12486;&#12461;&#12473;&#12488;&#12290;
		 */
		public java.lang.String getSampleText() {
			return (java.lang.String) this.getMap().get(Entity.ID_SAMPLE_TEXT);
		}

		/**
		 * &#12486;&#12461;&#12473;&#12488;&#12434;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;
		 * @param sampleText &#12486;&#12461;&#12473;&#12488;&#12290;
		 */
		public void setSampleText(final java.lang.String sampleText) {
			this.getMap().put(Entity.ID_SAMPLE_TEXT, sampleText);
		}

		/**
		 * &#25968;&#20516;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
		 * @return &#25968;&#20516;&#12290;
		 */
		public java.math.BigDecimal getSampleNumeric() {
			return (java.math.BigDecimal) this.getMap().get(Entity.ID_SAMPLE_NUMERIC);
		}

		/**
		 * &#25968;&#20516;&#12434;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;
		 * @param sampleNumeric &#25968;&#20516;&#12290;
		 */
		public void setSampleNumeric(final java.math.BigDecimal sampleNumeric) {
			this.getMap().put(Entity.ID_SAMPLE_NUMERIC, sampleNumeric);
		}

		/**
		 * &#26085;&#20184;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
		 * @return &#26085;&#20184;&#12290;
		 */
		public java.sql.Date getSampleDate() {
			return (java.sql.Date) this.getMap().get(Entity.ID_SAMPLE_DATE);
		}

		/**
		 * &#26085;&#20184;&#12434;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;
		 * @param sampleDate &#26085;&#20184;&#12290;
		 */
		public void setSampleDate(final java.sql.Date sampleDate) {
			this.getMap().put(Entity.ID_SAMPLE_DATE, sampleDate);
		}

		/**
		 * &#12469;&#12531;&#12503;&#12523;&#36984;&#25246;&#32930;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
		 * @return &#12469;&#12531;&#12503;&#12523;&#36984;&#25246;&#32930;&#12290;
		 */
		public java.lang.String getSampleSelect() {
			return (java.lang.String) this.getMap().get(Entity.ID_SAMPLE_SELECT);
		}

		/**
		 * &#12469;&#12531;&#12503;&#12523;&#36984;&#25246;&#32930;&#12434;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;
		 * @param sampleSelect &#12469;&#12531;&#12503;&#12523;&#36984;&#25246;&#32930;&#12290;
		 */
		public void setSampleSelect(final java.lang.String sampleSelect) {
			this.getMap().put(Entity.ID_SAMPLE_SELECT, sampleSelect);
		}


	}
	/**
	 * &#12524;&#12467;&#12540;&#12489;ID&#12501;&#12451;&#12540;&#12523;&#12489;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
	 * @return &#12524;&#12467;&#12540;&#12489;ID&#12501;&#12451;&#12540;&#12523;&#12489;&#12290;
	 */
	public SampleIdField getSampleIdField() {
		return (SampleIdField) this.getField(Entity.ID_SAMPLE_ID);
	}

	/**
	 * &#12486;&#12461;&#12473;&#12488;&#12501;&#12451;&#12540;&#12523;&#12489;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
	 * @return &#12486;&#12461;&#12473;&#12488;&#12501;&#12451;&#12540;&#12523;&#12489;&#12290;
	 */
	public SampleTextField getSampleTextField() {
		return (SampleTextField) this.getField(Entity.ID_SAMPLE_TEXT);
	}

	/**
	 * &#25968;&#20516;&#12501;&#12451;&#12540;&#12523;&#12489;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
	 * @return &#25968;&#20516;&#12501;&#12451;&#12540;&#12523;&#12489;&#12290;
	 */
	public SampleNumericField getSampleNumericField() {
		return (SampleNumericField) this.getField(Entity.ID_SAMPLE_NUMERIC);
	}

	/**
	 * &#26085;&#20184;&#12501;&#12451;&#12540;&#12523;&#12489;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
	 * @return &#26085;&#20184;&#12501;&#12451;&#12540;&#12523;&#12489;&#12290;
	 */
	public SampleDateField getSampleDateField() {
		return (SampleDateField) this.getField(Entity.ID_SAMPLE_DATE);
	}

	/**
	 * &#12469;&#12531;&#12503;&#12523;&#36984;&#25246;&#32930;&#12501;&#12451;&#12540;&#12523;&#12489;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
	 * @return &#12469;&#12531;&#12503;&#12523;&#36984;&#25246;&#32930;&#12501;&#12451;&#12540;&#12523;&#12489;&#12290;
	 */
	public SampleSelectField getSampleSelectField() {
		return (SampleSelectField) this.getField(Entity.ID_SAMPLE_SELECT);
	}
}

			</pre>
		</div>
		<p>
			テーブルクラスのコンストラクタで、テーブルの構造を定義しています。
			基本的にdataforms2.jarではRecordIdFieldから派生したクラスをaddPkFieldメソッドで主キーとして設定します。
			主キー自動生成を設定するとthis.setAutoIncrementId(true);というコードが生成され、
			レコード追加する際にシーケンス等を使用して自動的に主キーが生成されます。
			通常のフィールドはaddFieldメソッドを使用してフィールドクラスを追加します。
		</p>
		<p>
			テーブルクラスには必ずEntityクラスが定義されています。
			Daoクラスでテーブルのレコードデータの入れ物としてはMap&lt;String, Object&gt;を使用しています。
			このEntityクラスはこのMapオブジェクトを操作するため物です。
			Entityクラスにはテーブルに配置されたフィールド文のゲッター、セッターが定義されています。
			登録するデータを作成したり、読み込んだーデータを取得する際に使用します。
			また、EntityクラスにはフィールドIDの定数が定義されています。
		</p>
		<p>
			テーブルにはそのテーブルに配置されたフィールドのインスタンスを取得するメソッドも生成されています。
			以下のコードではtextField1とtextField2は同じフィールドのインスタンスになります。
		</p>
		<div class="filecaption">テーブルからフィールドの取得</div>
		<div class="wrappre">
			<pre>
SampleTable table = new SampleTable();
SampleTextField textField1 = table.getSampleTextField();
SampleTextField textField2 = (SampleTextField) this.getField(Entity.ID_SAMPLE_TEXT);
			</pre>
		</div>
		<p>
			getJoinConditionメソッドは他のテーブルとの結合条件を生成するためのメソッドです。
			この結合条件の生成処理はXxxTableRelationクラスで行っており、
			テーブルの結合条件はXxxTableRelationクラスに記述する必要があります。
			XxxTableRelationクラスはXxxTableクラスが作成されるタイミングで作成されます。
			その後開発ツールでXxxTableクラスのソースを更新するときには更新されることはありません。
		</p>
		<p>
			以下に開発ツールで生成したSampleTableRelation.javaを示します。
			このクラスではSampleTableにHogeTableをjoinした場合の条件式を記述します。
		</p>
		<p>
			joinの際の条件式の設定は外部キーを定義する方法と、
			外部キーは設定せずに条件式のみ設定する方法があります。
		</p>
		<p>
			static {}でForeignKeyのインスタンスを追加することにより、外部キーを追加することができます。
			外部キーを追加することにより自動的にjoinの際の条件式も生成されるようになります。
			外部キーを追加した後、テーブル管理で該当テープを表示すると、構造の差分有と表示されます。
			テーブル構造の更新を行うと、データベースに外部キーを作成することができます。
		</p>
		<p>
			外部キーを使用しない結合条件を生成したい場合、getJoinConditionメソッドに条件作成処理を記述します。
			以下の例ではHogeTableとの結合条件を生成する処理がコメントアウトされた状態で入っています。
			この記述を参考に結合条件式の生成処理を作成してください。
		</p>
		<div class="filecaption">テーブル関連定義クラス</div>
		<div class="wrappre">
			<pre>
package sample.dao;

import java.util.ArrayList;
import java.util.List;

import dataforms.dao.ForeignKey;
import dataforms.dao.Table;
import dataforms.dao.TableRelation;

/**
 * SampleTableの関係を定義するクラスです。
 *
 */
public class SampleTableRelation extends TableRelation {

	/**
	 * 外部キーリスト。
	 */
	private static List<ForeignKey> foreignKeyList = null;

	/**
	 * 外部キーリストの定義。
	 * <pre>
	 * この初期化処理で外部キーを定義することにより、自動的に外部キーが設定されます。
	 * </pre>
	 */
	static {
		foreignKeyList = new ArrayList<ForeignKey>();
		/*
		 * 以下の定義を有効にすると外部キーHogeTableに対する外部キーを設定します。
		 * この設定だけでHogeTableとの結合条件も生成されるようになります。
		 */
		// foreignKeyList.add(new ForeignKey("fkSampleTable01", SampleTable.Entity.ID_HOGE_ID, HogeTable.class));
	}

	@Override
	public List<ForeignKey> getForeignKeyList() {
		return foreignKeyList;
	}

	/**
	 * コンストラクタ。
	 * @param table 対象テーブル。
	 */
	public SampleTableRelation(final Table table) {
		super(table);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getJoinCondition(final Table joinTable, final String alias) {
		/*
		 * 外部キーを設定せずに結合条件を生成する場合は以下を有効にします。
		 */
/*
		if (joinTable instanceof HogeTable) {
			return this.getTable().getLinkFieldCondition(HogeTable.Entity.ID_HOGE_ID, joinTable, alias);
		}
*/
		return super.getJoinCondition(joinTable, alias);
	}
}
			</pre>
		</div>
		<h2>レコードの追加、更新、削除</h2>
		<p>
			テーブルにレコードを追加、更新、削除するにはDaoクラスを使用します。
		</p>
		<div class="filecaption">レコードの追加、更新、削除</div>
		<div class="wrappre">
			<pre>
Dao dao = new Dao(this);
SampleTable.Entity e = new SampleTable.Entity();
e.setSampleText("sample-text");
e.setSampleNumeric(BigDecimal.valueOf(1234.0));
e.setSampleDate(DateTimeUtil.getCurrentDate());
e.setSampleSelect("1");
e.setCreateUserId(Long.valueOf(0));
e.setUpdateUserId(Long.valueOf(0));
dao.executeInsert(new SampleTable(), e.getMap()); // レコードの追加
logger.debug(() -> "sampleId=" + e.getSampleId());// 自動生成されたIDを表示
e.setSampleText("sample-text-update");
dao.executeUpdate(new SampleTable(), e.getMap()); // レコードの更新
dao.executeDelete(new SampleTable(), e.getMap()); // レコードの削除
			</pre>
		</div>
		<p>
			この処理を実行すると以下の様なSQLが生成されます。
			executeInsertメソットではシーケンスで主キーを生成してからinsert文を実行しています。
			executeInsertの実行で、map中に生成された主キーの値が設定されます。
			このコードのexecuteUpdateは主キーで限定してレコードを更新します。
			executeUpdateは更新対象フィールドを限定したり、更新条件を設定することができる引数構成も存在します。
			このコードのexecuteDeleteも主キーで限定してレコードを削除します。
			executeDeleteは更新条件を設定することができる引数構成も存在します。
			Javadocを参照してください。
		<p>
		<div class="filecaption">実行されたSQL</div>
		<div class="wrappre">
			<pre>
2021/11/05 14:16:18.850 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser sql=select seq from (values next value for sample_seq) t(seq)
2021/11/05 14:16:18.850 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser sql=insert into sample (sample_id,sample_text,sample_numeric,sample_date,sample_select,create_user_id,create_timestamp,update_user_id,update_timestamp) values (:sample_id,:sample_text,:sample_numeric,:sample_date,:sample_select,:create_user_id,current_timestamp,:update_user_id,current_timestamp)
2021/11/05 14:16:18.850 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 1 :sample_id=403
2021/11/05 14:16:18.850 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 2 :sample_text=sample-text
2021/11/05 14:16:18.850 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 3 :sample_numeric=1234.0
2021/11/05 14:16:18.850 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 4 :sample_date=2021-11-05
2021/11/05 14:16:18.850 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 5 :sample_select=1
2021/11/05 14:16:18.850 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 6 :create_user_id=0
2021/11/05 14:16:18.850 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 7 :update_user_id=0
2021/11/05 14:16:18.851 [http-nio-8080-exec-7] DEBUG  sample.api.Api313 sampleId=403
2021/11/05 14:16:18.851 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser sql=update sample set
sample_text = :sample_text
, sample_numeric = :sample_numeric
, sample_date = :sample_date
, sample_select = :sample_select
, update_user_id = :update_user_id
, update_timestamp = current_timestamp
where
sample_id = :sample_id

2021/11/05 14:16:18.851 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 1 :sample_text=sample-text-update
2021/11/05 14:16:18.851 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 2 :sample_numeric=1234.0
2021/11/05 14:16:18.851 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 3 :sample_date=2021-11-05
2021/11/05 14:16:18.851 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 4 :sample_select=1
2021/11/05 14:16:18.851 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 5 :update_user_id=0
2021/11/05 14:16:18.851 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 6 :sample_id=403
2021/11/05 14:16:18.852 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser sql=delete from sample where sample_id = :sample_id

2021/11/05 14:16:18.852 [http-nio-8080-exec-7] DEBUG  dataforms.dao.sqlgen.SqlParser 1 :sample_id=403
			</pre>
		</div>
		<h2>問合せクラス</h2>
		<h3>単純な問合せ</h3>
		<p>
			SQLのselect文はJavaのQueryクラスを使用して記述します。
			SQLのselect文を直接記述することはほとんどありません。
		</p>
		<p>
			以下のようなシンプルなSQLを考えてみます。
		</p>
		<div class="filecaption">シンプルなSQL</div>
		<div class="wrappre">
			<pre>
select * from sample
			</pre>
		</div>
		<p>
			このSQLに対応する問合せクラスは以下のようになります。
		</p>
		<div class="filecaption">シンプルなQueryクラス</div>
		<div class="wrappre">
			<pre>
package sample.dao;

import dataforms.dao.Query;

/**
 * &#21336;&#32020;&#12394;&#21839;&#12356;&#21512;&#12431;&#12379;&#12290;
 *
 */
public class SampleQuery extends Query {
	/**
	 * &#12467;&#12531;&#12473;&#12488;&#12521;&#12463;&#12479;&#12290;
	 */
	public SampleQuery() {
		SampleTable table = new SampleTable();
		this.setFieldList(table.getFieldList());	// select *
		this.setMainTable(table);			// from sample
	}
}
			</pre>
		</div>
<!--
		<p>
			同様の問合せはSingleTableQueryクラスを使用して作成することができます。

		</p>
		<div class="wrappre">
			<pre>SingleTableQuery q = new SingleTableQuery(new SampleTable());</pre>
		</div>
 -->
		<p>
			この問合せクラスを実行するには以下のようにDaoクラスを使用します。
		</p>
		<div class="filecaption">問合せクラスの実行</div>
		<div class="wrappre">
			<pre>
List&lt;Map&lt;String, Object&gt;&gt; result = dao.executeQuery(new SampleQuery());  // &#21839;&#21512;&#12379;&#12434;&#34892;&#12356;&#12289;&#12381;&#12398;&#32080;&#26524;&#12434;Map&#12398;List&#12391;&#36820;&#12375;&#12414;&#12377;&#12290;
logger.debug(() -&gt; &quot;result=&quot; + JSON.encode(result, true));		//  問合せ結果をJSON形式でlog出力します。
for (Map&lt;String, Object&gt; m: result) {
	SampleTable.Entity e = new SampleTable.Entity(m);
	logger.debug(&quot;{},{},{},{}\n&quot;, e.getSampleId(), e.getSampleText(), e.getSampleNumeric(), e.getSampleDate());
}
			</pre>
		</div>
		<p>
			上記の実行ログを以下に示します。
		</p>
		<div class="filecaption">問合せクラスの実行</div>
		<div class="wrappre">
			<pre>
2021/11/05 14:52:20.041 [http-nio-8080-exec-8] DEBUG  dataforms.dao.sqlgen.SqlParser sql=select
m.sample_id as sample_id
,m.sample_text as sample_text
,m.sample_numeric as sample_numeric
,m.sample_date as sample_date
,m.sample_select as sample_select
,m.create_user_id as create_user_id
,m.create_timestamp as create_timestamp
,m.update_user_id as update_user_id
,m.update_timestamp as update_timestamp
 from sample as  m

2021/11/05 14:52:20.042 [http-nio-8080-exec-8] DEBUG  sample.api.Api3141 result=[
	{
		"createUserId": 1,
		"sampleId": 201,
		"sampleSelect": null,
		"updateUserId": 1,
		"sampleDate": 1635692400000,
		"sampleNumeric": 10.00,
		"updateTimestamp": 1635730742807,
		"sampleText": "aaa",
		"createTimestamp": 1635730742807
	},
	{
		"createUserId": 1,
		"sampleId": 202,
		"sampleSelect": null,
		"updateUserId": 1,
		"sampleDate": 1635778800000,
		"sampleNumeric": 20.00,
		"updateTimestamp": 1635730759674,
		"sampleText": "aab",
		"createTimestamp": 1635730759674
	},
	{
		"createUserId": 1,
		"sampleId": 301,
		"sampleSelect": "1",
		"updateUserId": 1,
		"sampleDate": 1635692400000,
		"sampleNumeric": 123.00,
		"updateTimestamp": 1635741538316,
		"sampleText": "test",
		"createTimestamp": 1635741538316
	}
]
2021/11/05 14:52:20.042 [http-nio-8080-exec-8] DEBUG  sample.api.Api3141 201,aaa,10.00,2021-11-01T00:00:00.000+0900

2021/11/05 14:52:20.042 [http-nio-8080-exec-8] DEBUG  sample.api.Api3141 202,aab,20.00,2021-11-02T00:00:00.000+0900

2021/11/05 14:52:20.042 [http-nio-8080-exec-8] DEBUG  sample.api.Api3141 301,test,123.00,2021-11-01T00:00:00.000+0900
			</pre>
		</div>
		<p>
			問合せの結果はMapに入ってきます。
			SampleTable.Entityクラスを使用すると、このMap中の値を簡単に取得することができます。
		</p>
		<h3>条件の設定</h3>
		<p>
			where句を指定するには条件の対象になるフィールドリストを指定する方法と、SQLの条件式を直接指定する方法があります。
			フィールドリストを指定例を以下に示します。
			setConditionFieldListメソッドで検索条件の対象となるフィールドを指定し、setConditionDataメソッドでその条件の値マップを指定します。
			この例ではフィールドID"sampleText"の部分一致と"sampleNumeric"の範囲指定を行っています。
		</p>
		<div class="filecaption">条件フィールドリストの指定例</div>
		<div class="wrappre">
			<pre>
Dao dao = new Dao(this);
// &#26465;&#20214;&#24335;&#12434;&#29983;&#25104;&#12377;&#12427;&#12501;&#12451;&#12540;&#12523;&#12489;&#12522;&#12473;&#12488;&#12434;&#20316;&#25104;&#12375;&#12414;&#12377;&#12290;
FieldList flist = new FieldList();
flist.addField(new SampleTextField(SampleTable.Entity.ID_SAMPLE_TEXT)).setMatchType(MatchType.PART);
flist.addField(new SampleNumericField(SampleTable.Entity.ID_SAMPLE_NUMERIC + &quot;From&quot;)).setMatchType(MatchType.RANGE_FROM);
flist.addField(new SampleNumericField(SampleTable.Entity.ID_SAMPLE_NUMERIC + &quot;To&quot;)).setMatchType(MatchType.RANGE_TO);
// &#21508;&#12501;&#12451;&#12540;&#12523;&#12489;&#12398;&#20516;&#12434;&#25351;&#23450;&#12375;&#12414;&#12377;&#12290;
Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();
data.put(SampleTable.Entity.ID_SAMPLE_TEXT, &quot;te&quot;);
data.put(SampleTable.Entity.ID_SAMPLE_NUMERIC + &quot;From&quot;, 100);
// &#26465;&#20214;&#12434;&#25351;&#23450;&#12375;&#12383;&#21839;&#12356;&#21512;&#12431;&#12379;&#12434;&#23455;&#34892;&#12290;
SampleQuery query = new SampleQuery();
query.setConditionFieldList(flist);
query.setConditionData(data);
List&lt;Map&lt;String, Object&gt;&gt; result = dao.executeQuery(query);	// &#21839;&#21512;&#12379;&#12434;&#34892;&#12356;&#12289;&#12381;&#12398;&#32080;&#26524;&#12434;Map&#12398;List&#12391;&#36820;&#12375;&#12414;&#12377;&#12290;
logger.debug(() -&gt; &quot;result=&quot; + JSON.encode(result, true));	// &#21839;&#21512;&#12379;&#32080;&#26524;&#12434;JSON&#24418;&#24335;&#12391;log&#20986;&#21147;&#12375;&#12414;&#12377;&#12290;
			</pre>
		</div>
		<p>
			上記の処理を実行すると以下のログが出力されます。
			条件フィールドは"sampleText","sampleNumericFrom","sampleNumericTo"の3つのフィールドが指定されていますが、
			条件値のマップは"sampleText","sampleNumericFrom"2つの値を指定しています。
			そのため"sampleNumericTo"に対応する条件式は生成されません。
		</p>
		<p>
			QueryResultFormに表示するデータの検索処理は、QueryFormに配置されたフィールドリストをsetConditionFieldListに、
			入力データのマップをsetConditionDataに指定して問合せを実行するようになっています。
		</p>
		<p>
			この処理を実行すると以下のようなログが出力されます。
		</p>
		<div class="filecaption">条件フィールドリストの実行ログ</div>
		<div class="wrappre">
			<pre>
2021/11/05 15:01:38.922 [http-nio-8080-exec-3] DEBUG  dataforms.dao.sqlgen.SqlParser sql=select
m.sample_id as sample_id
,m.sample_text as sample_text
,m.sample_numeric as sample_numeric
,m.sample_date as sample_date
,m.sample_select as sample_select
,m.create_user_id as create_user_id
,m.create_timestamp as create_timestamp
,m.update_user_id as update_user_id
,m.update_timestamp as update_timestamp
 from sample as  m
 where m.sample_text like :sample_text {escape '\'}  and m.sample_numeric &gt;= :sample_numeric_from
2021/11/05 15:01:38.923 [http-nio-8080-exec-3] DEBUG  dataforms.dao.sqlgen.SqlParser 1 :sample_text=%te%
2021/11/05 15:01:38.923 [http-nio-8080-exec-3] DEBUG  dataforms.dao.sqlgen.SqlParser 2 :sample_numeric_from=100
2021/11/05 15:01:38.924 [http-nio-8080-exec-3] DEBUG  sample.api.Api3142 result=[
	{
		&quot;createUserId&quot;: 1,
		&quot;sampleId&quot;: 301,
		&quot;sampleSelect&quot;: &quot;1&quot;,
		&quot;updateUserId&quot;: 1,
		&quot;sampleDate&quot;: 1635692400000,
		&quot;sampleNumeric&quot;: 123.00,
		&quot;updateTimestamp&quot;: 1635741538316,
		&quot;sampleText&quot;: &quot;test&quot;,
		&quot;createTimestamp&quot;: 1635741538316
	}
]
			</pre>
		</div>
		<h3>複雑な条件式の指定</h3>
		<p>
			setConditionFieldListで指定した条件は全てandで結合されます。
			and orを組み合わせた条件式を作成するにはsetConditionExpressionを使用します。
		</p>
		<div class="filecaption">複雑な条件式の指定例</div>
		<div class="wrappre">
			<pre>
Dao dao = new Dao(this);
SampleTable table = new SampleTable();
// 条件式を生成するフィールドリストを作成します。
FieldList flist = new FieldList();
flist.addField(table.getSampleTextField()).setMatchType(MatchType.PART);
flist.addField(table.getSampleSelectField());
ConditionExpressionList cond1 = new ConditionExpressionList(Operator.AND, flist);
ConditionExpressionList cond2 = new ConditionExpressionList(Operator.AND);
cond2.addField(table.getSampleNumericField());
ConditionExpressionList cond = new ConditionExpressionList(Operator.OR);
cond.add(cond1);
cond.add(cond2);
// 条件を指定した問い合わせを実行。
SampleQuery query = new SampleQuery();
query.setConditionExpression(cond);
SampleTable.Entity e = new SampleTable.Entity();
e.setSampleText("test");
e.setSampleSelect("1");
e.setSampleNumeric(BigDecimal.valueOf(123));
query.setConditionData(e.getMap());
List&lt;Map&lt;String, Object&gt;&gt; result = dao.executeQuery(query);	// &#21839;&#21512;&#12379;&#12434;&#34892;&#12356;&#12289;&#12381;&#12398;&#32080;&#26524;&#12434;Map&#12398;List&#12391;&#36820;&#12375;&#12414;&#12377;&#12290;
logger.debug(() -&gt; &quot;result=&quot; + JSON.encode(result, true));	// &#21839;&#21512;&#12379;&#32080;&#26524;&#12434;JSON&#24418;&#24335;&#12391;log&#20986;&#21147;&#12375;&#12414;&#12377;&#12290;
			</pre>
		</div>
		<p>
			この処理を実行すると以下のログが出力されます。
		</p>
		<div class="filecaption">複雑な条件式の実行結果</div>
		<div class="wrappre">
			<pre>
2021/11/05 16:15:17.690 [http-nio-8080-exec-4] DEBUG  dataforms.dao.sqlgen.SqlParser sql=select
m.sample_id as sample_id
,m.sample_text as sample_text
,m.sample_numeric as sample_numeric
,m.sample_date as sample_date
,m.sample_select as sample_select
,m.create_user_id as create_user_id
,m.create_timestamp as create_timestamp
,m.update_user_id as update_user_id
,m.update_timestamp as update_timestamp
 from sample as  m
 where ((m.sample_text like :sample_text {escape '\'}  and m.sample_select = :sample_select) or (m.sample_numeric = :sample_numeric))
2021/11/05 16:15:17.690 [http-nio-8080-exec-4] DEBUG  dataforms.dao.sqlgen.SqlParser 1 :sample_text=%test%
2021/11/05 16:15:17.690 [http-nio-8080-exec-4] DEBUG  dataforms.dao.sqlgen.SqlParser 2 :sample_select=1
2021/11/05 16:15:17.691 [http-nio-8080-exec-4] DEBUG  dataforms.dao.sqlgen.SqlParser 3 :sample_numeric=123
2021/11/05 16:15:17.691 [http-nio-8080-exec-4] DEBUG  sample.api.Api3143 result=[
	{
		"createUserId": 1,
		"sampleId": 301,
		"sampleSelect": "1",
		"updateUserId": 1,
		"sampleDate": 1635692400000,
		"sampleNumeric": 123.00,
		"updateTimestamp": 1635741538316,
		"sampleText": "test",
		"createTimestamp": 1635741538316
	}
]
			</pre>
		</div>
		<h3>SQLの条件式を直接指定</h3>
		<p>
			SQLの条件式を直接指定する場合は以下のようにQueryクラスのsetConditionを使用します。
			Javaクラスで管理するフィールドIDは"sampleText"の様なキャメル形式ですが、SQLのカラム名は"sample_text"の様にスネーク形式になります。
			SQLの条件式はスネーク形式で記述する必要があります。
		</p>
		<div class="filecaption">SQL条件式の直接指定</div>
		<div class="wrappre">
			<pre>
Dao dao = new Dao(this);
// &#26465;&#20214;&#12434;&#25351;&#23450;&#12375;&#12383;&#21839;&#12356;&#21512;&#12431;&#12379;&#12434;&#23455;&#34892;&#12290;
SampleQuery query = new SampleQuery();
query.setCondition(&quot;m.sample_text = :sample_text&quot;);	// where&#21477;&#12398;&#26465;&#20214;&#24335;&#12434;&#30452;&#25509;&#25351;&#23450;&#12375;&#12414;&#12377;&#12290;
SampleTable.Entity e = new SampleTable.Entity();		// &#26465;&#20214;&#12487;&#12540;&#12479;&#12434;&#20316;&#25104;&#12375;&#12390;&#25351;&#23450;&#12375;&#12414;&#12377;&#12290;
e.setSampleText(&quot;aaa&quot;);
query.setConditionData(e.getMap());
List&lt;Map&lt;String, Object&gt;&gt; result = dao.executeQuery(query);	// &#21839;&#21512;&#12379;&#12434;&#34892;&#12356;&#12289;&#12381;&#12398;&#32080;&#26524;&#12434;Map&#12398;List&#12391;&#36820;&#12375;&#12414;&#12377;&#12290;
logger.debug(() -&gt; &quot;result=&quot; + JSON.encode(result, true));	// &#21839;&#21512;&#12379;&#32080;&#26524;&#12434;JSON&#24418;&#24335;&#12391;log&#20986;&#21147;&#12375;&#12414;&#12377;&#12290;
			</pre>
		</div>
		<p>
			この処理を実行すると以下のようなログが出力されます。
		</p>
		<div class="filecaption">SQL条件式の直接指定</div>
		<div class="wrappre">
			<pre>
2021/11/05 16:46:25.472 [http-nio-8080-exec-6] DEBUG  dataforms.dao.sqlgen.SqlParser sql=select
m.sample_id as sample_id
,m.sample_text as sample_text
,m.sample_numeric as sample_numeric
,m.sample_date as sample_date
,m.sample_select as sample_select
,m.create_user_id as create_user_id
,m.create_timestamp as create_timestamp
,m.update_user_id as update_user_id
,m.update_timestamp as update_timestamp
 from sample as  m
 where m.sample_text = :sample_text
2021/11/05 16:46:25.472 [http-nio-8080-exec-6] DEBUG  dataforms.dao.sqlgen.SqlParser 1 :sample_text=aaa
2021/11/05 16:46:25.473 [http-nio-8080-exec-6] DEBUG  sample.api.Api3144 result=[
	{
		"createUserId": 1,
		"sampleId": 201,
		"sampleSelect": null,
		"updateUserId": 1,
		"sampleDate": 1635692400000,
		"sampleNumeric": 10.00,
		"updateTimestamp": 1635730742807,
		"sampleText": "aaa",
		"createTimestamp": 1635730742807
	}
]
			</pre>
		</div>
		<p>
			setConditionFieldListまたはsetConditionExpressionとsetConditionを同時に指定した場合、両方の条件のANDで検索します。
		</p>
		<h3>テーブルの結合</h3>
		<p>
			すでに作成したSampleTableと結合する以下のJoinTestTableを作成し、テーブルの結合方法を説明していきます。
		</p>
		<div class="filecaption">JoinTestTable.javaの定義</div>
		<div class="wrappre">
			<pre>
/**
 * Joinテストテーブルクラス。
 *
 */
public class JoinTestTable extends Table {
	/**
	 * コンストラクタ。
	 */
	public JoinTestTable() {
		this.setAutoIncrementId(true);
		this.setComment("Joinテストテーブル");
		this.addPkField(new JoinTestIdField()); //join test ID.
		<b>this.addField(new SampleIdField()); //レコードID</b>
		this.addField(new JoinTestTextField()); //テキスト
		this.addUpdateInfoFields();
	}

	・
	・
	・
}
			</pre>
		</div>
		<p>
			このテーブルの2カラム目にはSampleIdFieldが配置されており、この項目でSampleTableに結合します。
		</p>
		<p>
			複数のテーブルを結合して検索するには、あらかじめテーブル間の関係を定義する必要があります。
			開発ツールでJoinTestTableを作成すると、JoinTestTableRelation.javaというソースファイルが同時に作成されます。
			このJoinTestTableRelationクラスでJoinTestTableにJoinするテーブルの結合条件を定義します。
			JoinTestTableRelationクラスでテーブル間の関係を定義するには以下の2つの方法があります。
			<ol>
				<li>
					JoinTestTableRelationクラスで外部キーを定義。
				</li>
				<li>
					JoinTestTableRelationクラスのgetJoinConditionで結合条件を定義。
				</li>
			</ol>
		</p>
		<p>
			以下にJoinTestTableRelationで外部キーを定義した例を示します。
			自動生成されたJoinTestTableRelationには、static {}の部分にforeignKeyListにForeignKeyクラスの
			インスタンスを追加する処理がコメントアウトされた状態で記述されています。
			このコメントを解除し適切に修正します。
		</p>
		<div class="filecaption">JoinTestTableRelationでの外部キーの定義</div>
		<div class="wrappre">
			<pre>
package sample.dao;

import java.util.ArrayList;
import java.util.List;

import dataforms.dao.ForeignKey;
import dataforms.dao.Table;
import dataforms.dao.TableRelation;

/**
 * JoinTestTable&#12398;&#38306;&#20418;&#12434;&#23450;&#32681;&#12377;&#12427;&#12463;&#12521;&#12473;&#12391;&#12377;&#12290;
 *
 */
public class JoinTestTableRelation extends TableRelation {

	/**
	 * &#22806;&#37096;&#12461;&#12540;&#12522;&#12473;&#12488;&#12290;
	 */
	private static List&lt;ForeignKey&gt; foreignKeyList = null;

	/**
	 * &#22806;&#37096;&#12461;&#12540;&#12522;&#12473;&#12488;&#12398;&#23450;&#32681;&#12290;
	 * &lt;pre&gt;
	 * &#12371;&#12398;&#21021;&#26399;&#21270;&#20966;&#29702;&#12391;&#22806;&#37096;&#12461;&#12540;&#12434;&#23450;&#32681;&#12377;&#12427;&#12371;&#12392;&#12395;&#12424;&#12426;&#12289;&#33258;&#21205;&#30340;&#12395;&#22806;&#37096;&#12461;&#12540;&#12364;&#35373;&#23450;&#12373;&#12428;&#12414;&#12377;&#12290;
	 * &lt;/pre&gt;
	 */
	static {
		foreignKeyList = new ArrayList&lt;ForeignKey&gt;();
		<b>foreignKeyList.add(new ForeignKey(&quot;fkJoinTestTable01&quot;, JoinTestTable.Entity.ID_SAMPLE_ID, SampleTable.class));</b>
	}

	@Override
	public List&lt;ForeignKey&gt; getForeignKeyList() {
		return foreignKeyList;
	}

	/**
	 * &#12467;&#12531;&#12473;&#12488;&#12521;&#12463;&#12479;&#12290;
	 * @param table &#23550;&#35937;&#12486;&#12540;&#12502;&#12523;&#12290;
	 */
	public JoinTestTableRelation(final Table table) {
		super(table);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getJoinCondition(final Table joinTable, final String alias) {
		/*
		 * &#22806;&#37096;&#12461;&#12540;&#12434;&#35373;&#23450;&#12379;&#12378;&#12395;&#32080;&#21512;&#26465;&#20214;&#12434;&#29983;&#25104;&#12377;&#12427;&#22580;&#21512;&#12399;&#20197;&#19979;&#12434;&#26377;&#21177;&#12395;&#12375;&#12414;&#12377;&#12290;
		 */
/*
		if (joinTable instanceof HogeTable) {
			return this.getTable().getLinkFieldCondition(HogeTable.Entity.ID_HOGE_ID, joinTable, alias);
		}
*/
		return super.getJoinCondition(joinTable, alias);
	}
}

			</pre>
		</div>
		<p>
			TableRelationクラスで外部キーを定義しWebアプリケーションをデプロイした後、
			開発ツールの「テーブル管理」で該当するテーブルを表示するとJavaクラスのテーブルとデータベース中のテーブルの差分が表示されます。
			差分の表示されたテーブルの構造を更新するだけで、外部キーを設定することができます。
		</p>
		<p>
			外部キーは問合せの性能を上げデータの一貫性を保つ効果がありますが、
			外部キーの操作に関するSQLを作成する必要があり管理に手間がかかります。
			これに対しdataforms2.jarではJavaのクラスで外部キーを定義するだけで、
			外部キーを操作するSQLを記述する必要はありません。
		</p>
		<figure>
			<figcaption>テーブル管理画面の外部キーの適用方法</figcaption>
			<img src="fkey.png" style="width:50%; height:50%;"/>
		</figure>
		<p>
			開発ツールの「問合せJavaクラス作成」を使用すると、JoinTestTableとSampleTableを結合した問合せを簡単に作成することができます。
			定義された外部キーに対応した結合条件が生成されていることがわかります。
		</p>
		<figure>
			<figcaption>問合せJavaクラス作成</figcaption>
			<img src="query.png" style="width:50%; height:50%;"/>
		</figure>
		<p>
			上記の画面で作成した問合せクラスのソースは以下のようになります。
		</p>
		<div class="filecaption">生成された問合せクラス</div>
		<div class="wrappre">
			<pre>
package sample.dao;

import dataforms.field.base.FieldList;
import dataforms.dao.Query;
import sample.field.SampleDateField;
import sample.field.SampleTextField;
import sample.field.SampleNumericField;
import sample.field.SampleSelectField;
import dataforms.field.common.CreateTimestampField;
import dataforms.field.common.UpdateUserIdField;
import dataforms.field.common.CreateUserIdField;
import sample.field.SampleIdField;
import sample.field.JoinTestIdField;
import dataforms.util.NumberUtil;
import java.util.Map;
import dataforms.field.common.UpdateTimestampField;
import sample.field.JoinTestTextField;




/**
 * 問い合わせクラスです。
 *
 */
public class JoinTestQuery extends Query {
	/**
	 * Joinテストテーブル。
	 */
	private JoinTestTable joinTestTable = null;

	/**
	 * Joinテストテーブルを取得します。
	 * @return Joinテストテーブル。
	 */
	public JoinTestTable getJoinTestTable() {
		return this.joinTestTable;
	}

	/**
	 * サンプルテーブル。
	 */
	private SampleTable sampleTable = null;

	/**
	 * サンプルテーブルを取得します。
	 * @return サンプルテーブル。
	 */
	public SampleTable getSampleTable() {
		return this.sampleTable;
	}


	/**
	 * コンストラクタ.
	 */
	public JoinTestQuery() {
		this.setComment("Joinのテスト");
		this.setDistinct(false);
		this.joinTestTable = new JoinTestTable();
		this.joinTestTable.setAlias("m");
		this.sampleTable = new SampleTable();
		this.sampleTable.setAlias("s");

		this.setFieldList(new FieldList(
			this.joinTestTable.getJoinTestIdField()
			, this.joinTestTable.getSampleIdField()
			, this.joinTestTable.getJoinTestTextField()
			, this.joinTestTable.getCreateUserIdField()
			, this.joinTestTable.getCreateTimestampField()
			, this.joinTestTable.getUpdateUserIdField()
			, this.joinTestTable.getUpdateTimestampField()
			, this.sampleTable.getSampleTextField()
			, this.sampleTable.getSampleNumericField()
			, this.sampleTable.getSampleDateField()
			, this.sampleTable.getSampleSelectField()
		));
		this.setMainTable(joinTestTable);
		this.addInnerJoin(sampleTable);

	}

	/**
	 * Entity操作クラスです。
	 */
	public static class Entity extends dataforms.dao.Entity {

			・
			・
			・

	}

	/**
	 * join test ID.フィールドを取得します。
	 * @return join test ID.フィールド。
	 */
	public JoinTestIdField getJoinTestIdField() {
		return (JoinTestIdField) this.getField(Entity.ID_JOIN_TEST_ID);
	}

			・
			・
			・

}
			</pre>
		</div>
		<p>
			この問合せに対応するSQLを以下に示します。
		</p>
		<div class="filecaption">JoinTestQueryに対応するSQL</div>
		<div class="wrappre">
			<pre>
select
m.join_test_id as join_test_id
,m.sample_id as sample_id
,m.join_test_text as join_test_text
,m.create_user_id as create_user_id
,m.create_timestamp as create_timestamp
,m.update_user_id as update_user_id
,m.update_timestamp as update_timestamp
,s.sample_text as sample_text
,s.sample_numeric as sample_numeric
,s.sample_date as sample_date
,s.sample_select as sample_select
 from join_test as  m
  inner join  sample as s on m.sample_id=s.sample_id
  			</pre>
		</div>
		<p>
			外部キーでは定義できない結合条件を指定する場合は、JoinTestTableRelationクラスのgetJoinConditionのコメントを参考にして結合条件式を作成します。
			外部キーを使用しないで結合条件を定義する場合のコードは以下のようになります。
		</p>
		<div class="filecaption">外部キーを使用しない結合条件の定義</div>
		<div class="wrappre">
			<pre>
package sample.dao;

import java.util.ArrayList;
import java.util.List;

import dataforms.dao.ForeignKey;
import dataforms.dao.Table;
import dataforms.dao.TableRelation;

/**
 * JoinTestTable&#12398;&#38306;&#20418;&#12434;&#23450;&#32681;&#12377;&#12427;&#12463;&#12521;&#12473;&#12391;&#12377;&#12290;
 *
 */
public class JoinTestTableRelation extends TableRelation {

	/**
	 * &#22806;&#37096;&#12461;&#12540;&#12522;&#12473;&#12488;&#12290;
	 */
	private static List&lt;ForeignKey&gt; foreignKeyList = null;

	/**
	 * &#22806;&#37096;&#12461;&#12540;&#12522;&#12473;&#12488;&#12398;&#23450;&#32681;&#12290;
	 * &lt;pre&gt;
	 * &#12371;&#12398;&#21021;&#26399;&#21270;&#20966;&#29702;&#12391;&#22806;&#37096;&#12461;&#12540;&#12434;&#23450;&#32681;&#12377;&#12427;&#12371;&#12392;&#12395;&#12424;&#12426;&#12289;&#33258;&#21205;&#30340;&#12395;&#22806;&#37096;&#12461;&#12540;&#12364;&#35373;&#23450;&#12373;&#12428;&#12414;&#12377;&#12290;
	 * &lt;/pre&gt;
	 */
	static {
		foreignKeyList = new ArrayList&lt;ForeignKey&gt;();
		/*
		 * &#20197;&#19979;&#12398;&#23450;&#32681;&#12434;&#26377;&#21177;&#12395;&#12377;&#12427;&#12392;&#22806;&#37096;&#12461;&#12540;HogeTable&#12395;&#23550;&#12377;&#12427;&#22806;&#37096;&#12461;&#12540;&#12434;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;
		 * &#12371;&#12398;&#35373;&#23450;&#12384;&#12369;&#12391;HogeTable&#12392;&#12398;&#32080;&#21512;&#26465;&#20214;&#12418;&#29983;&#25104;&#12373;&#12428;&#12427;&#12424;&#12358;&#12395;&#12394;&#12426;&#12414;&#12377;&#12290;
		 */
		// foreignKeyList.add(new ForeignKey(&quot;fkJoinTestTable01&quot;, JoinTestTable.Entity.ID_HOGE_ID, HogeTable.class));
	}

	@Override
	public List&lt;ForeignKey&gt; getForeignKeyList() {
		return foreignKeyList;
	}

	/**
	 * &#12467;&#12531;&#12473;&#12488;&#12521;&#12463;&#12479;&#12290;
	 * @param table &#23550;&#35937;&#12486;&#12540;&#12502;&#12523;&#12290;
	 */
	public JoinTestTableRelation(final Table table) {
		super(table);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getJoinCondition(final Table joinTable, final String alias) {
		<b>if (joinTable instanceof SampleTable) {</b>
			<b>return this.getTable().getLinkFieldCondition(JoinTestTable.Entity.ID_SAMPLE_ID, joinTable, alias);</b>
		<b>}</b>
		return super.getJoinCondition(joinTable, alias);
	}
}
			</pre>
		</div>
		<p>
			この定義でもJoinTestQueryに対応するSQLは外部キーを使用した場合と変わりませんが、外部キーの作成は行われません。
		</p>
		<p>
			JoinTestTableRelationにテーブルの関連を定義しなくても、add((Inner)|(Left)|(Right))Joinメソッドにラムダ式を渡すことによって、
			その場で結合条件を設定することも可能です。
		</p>
		<div class="filecaption">ラムダ式での結合条件の指定</div>
		<div class="wrappre">
			<pre>
	/**
	 * コンストラクタ.
	 */
	public JoinTestQuery() {
		this.setComment("Joinのテスト");
		this.setDistinct(false);
		this.joinTestTable = new JoinTestTable();
		this.sampleTable = new SampleTable();

		this.setFieldList(new FieldList(
			this.joinTestTable.getJoinTestIdField()
			, this.joinTestTable.getSampleIdField()
			, this.joinTestTable.getJoinTestTextField()
			, this.joinTestTable.getCreateUserIdField()
			, this.joinTestTable.getCreateTimestampField()
			, this.joinTestTable.getUpdateUserIdField()
			, this.joinTestTable.getUpdateTimestampField()
			, this.sampleTable.getSampleTextField()
			, this.sampleTable.getSampleNumericField()
			, this.sampleTable.getSampleDateField()
			, this.sampleTable.getSampleSelectField()
		));
		this.setMainTable(joinTestTable);
		<b>this.addInnerJoin(sampleTable, (Table joinTable) -> {</b>
			<b>return this.joinTestTable.getLinkFieldCondition(JoinTestTable.Entity.ID_SAMPLE_ID, joinTable);</b>
		<b>});</b>
	}
			</pre>
		</div>
		<h3>副問合せ</h3>
		<p>
			dataforms2.jarで副問合せを実現するにはSubQueryクラスを使用します。
			SubQueryクラスはTableクラスからは派生しているため、QueryクラスでJoinする対象になります。
			SQLのselect文を()で囲むだけの副問合せに比べてSubQueryクラスのコード量は多くなります。
			そのため「問合せJavaクラス作成」にSubQueryクラスの生成機能も装備してあります。
		</p>
		<figure>
			<figcaption>副問合せの作成</figcaption>
			<img src="subquery.png" style="width:50%; height:50%;"/>
		</figure>
		<p>
			上記の画面で「副問合せ作成」ボタンを押下すると、対応した問合せの副問合せクラスを作成します。
			自動生成した副問合せのソースは以下のようになります。
		</p>
		<div class="filecaption">副問合せクラスの生成結果</div>
		<div class="wrappre">
			<pre>
package sample.dao;

import dataforms.dao.Table;
import dataforms.dao.SubQuery;
import sample.field.JoinTestIdField;
import sample.field.SampleDateField;
import sample.field.SampleTextField;
import sample.field.SampleNumericField;
import sample.field.SampleSelectField;
import dataforms.field.common.CreateTimestampField;
import dataforms.field.common.UpdateUserIdField;
import dataforms.field.common.CreateUserIdField;
import dataforms.field.common.UpdateTimestampField;
import sample.field.JoinTestTextField;
import sample.field.SampleIdField;


/**
 * JoinTestQuery&#12398;&#21103;&#21839;&#21512;&#12379;&#12290;
 *
 */
public class JoinTestSubQuery extends SubQuery {
	/**
	 * &#12467;&#12531;&#12473;&#12488;&#12521;&#12463;&#12479;&#12290;
	 */
	public JoinTestSubQuery() {
		super(new JoinTestQuery());
		this.setComment(this.getQuery().getClass().getSimpleName() + &quot;&#12398;&#21103;&#21839;&#21512;&#12379;&quot;);
	}

	/**
	 * &#21839;&#21512;&#12379;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
	 * @return &#21839;&#21512;&#12379;&#12290;
	 */
	public JoinTestQuery getJoinTestQuery() {
		return (JoinTestQuery) this.getQuery();
	}

	/**
	 * &#20182;&#12486;&#12540;&#12502;&#12523;&#12392;&#12398;&#12522;&#12531;&#12463;&#26465;&#20214;&#12434;&#20316;&#25104;&#12375;&#12414;&#12377;&#12290;
	 * &lt;pre&gt;
	 * &#20182;&#12398;&#12486;&#12540;&#12502;&#12523;&#12392;&#12398;&#32080;&#21512;&#12434;&#34892;&#12358;&#22580;&#21512;&#12434;&#20197;&#19979;&#12398;&#12467;&#12513;&#12531;&#12488;&#37096;&#20998;&#12434;&#21442;&#32771;&#12395;&#23455;&#35013;&#12375;&#12390;&#12367;&#12384;&#12373;&#12356;&#12290;
	 * &lt;/pre&gt;
	 * @param joinTable &#32080;&#21512;&#12377;&#12427;&#12486;&#12540;&#12502;&#12523;&#12398;&#12452;&#12531;&#12473;&#12479;&#12531;&#12473;&#12290;
	 * @param alias &#32080;&#21512;&#12377;&#12427;&#12486;&#12540;&#12502;&#12523;&#12398;&#21029;&#21517;&#12290;
	 */
	@Override
	public String getJoinCondition(final Table joinTable, final String alias) {
/*
		if (joinTable instanceof HogeTable) {
			return this.getLinkFieldCondition(JoinTestQuery.Entity.ID_HOGE_ID, joinTable, alias, HogeTable.Entity.ID_HOGE_ID);
		}
*/
		return super.getJoinCondition(joinTable, alias);
	}
	/**
	 * join test ID.&#12501;&#12451;&#12540;&#12523;&#12489;&#12434;&#21462;&#24471;&#12375;&#12414;&#12377;&#12290;
	 * @return join test ID.&#12501;&#12451;&#12540;&#12523;&#12489;&#12290;
	 */
	public JoinTestIdField getJoinTestIdField() {
		return (JoinTestIdField) this.getField(JoinTestQuery.Entity.ID_JOIN_TEST_ID);
	}

	・
	・
	・

}

			</pre>
		</div>
		<h3>フィールドの別名と集計関数</h3>
		<p>
			select文でカラムの別名を設定するにはAliasFieldというフィールドクラスを使用します。
			また集計を行うには以下の集計フィールドを使用します。
		</p>
		<table>
			<caption>
				集計フィールド一覧
			</caption>
			<thead>
				<tr>
					<th style="width:40px;">No.</th>
					<th>集計フィールドクラス</th>
					<th>機能</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td style="text-align: right;">1</td>
					<td>AvgField</td>
					<td>平均値を求めます。</td>
				</tr>
				<tr>
					<td style="text-align: right;">2</td>
					<td>CountField</td>
					<td>件数をカウントします。</td>
				</tr>
				<tr>
					<td style="text-align: right;">3</td>
					<td>MaxField</td>
					<td>最大値を求めます。</td>
				</tr>
				<tr>
					<td style="text-align: right;">4</td>
					<td>MinField</td>
					<td>最小値を求めます。</td>
				</tr>
				<tr>
					<td style="text-align: right;">5</td>
					<td>SumField</td>
					<td>合計値を求めます。</td>
				</tr>
			</tbody>
		</table>
		<p>
			「問合せJavaクラス作成」でフィールドの別名を設定すると、AliasFieldが生成されます。
			またプルダウンで集計フィールドを指定すると、対応する集計関数が生成されます。
			以下に、AliasFieldとCountFieldを生成する例を示します。
		</p>
		<figure>
			<figcaption>別名と集計フィールドの生成</figcaption>
			<img src="alias.png" style="width:50%; height:50%;"/>
		</figure>
		<p>
			上記の設定で生成した問合せクラスは以下のようになります。
		</p>
		<div class="filecaption">AliasFieldと集計フィールドの生成例</div>
		<div class="wrappre">
			<pre>

	/**
	 * コンストラクタ.
	 */
	public TestQuery() {
		this.setComment("別名、集計テスト");
		this.setDistinct(false);
		this.sampleTable = new SampleTable();
		this.sampleTable.setAlias("m");

		this.setFieldList(new FieldList(
			new CountField("sampleId", this.sampleTable.getSampleIdField())
			, new AliasField("sel", this.sampleTable.getSampleSelectField())
		));
		this.setMainTable(sampleTable);

	}
			</pre>
		</div>
		<p>
			この問合せクラスのSQLは以下のようになります。
		</p>
		<div class="filecaption">上記問合せのSQL生成結果</div>
		<div class="wrappre">
			<pre>
select
count(m.sample_id) as sample_id
,m.sample_select as sel
 from sample as  m
 group by m.sample_select
 			</pre>
		</div>
		<h3>任意のSQLフィールド</h3>
		<p>
			任意のSQL式を問合せ結果に含める場合はSqlFieldクラスを使用します。
			「問合せJavaクラス作成」画面でSqlFieldを作成するには以下の、ようにSQLフィールドリストに項目を追加します。
		</p>
		<figure>
			<figcaption>任意のSQLフィールドの生成</figcaption>
			<img src="sqlfield.png" style="width:50%; height:50%;"/>
		</figure>
		<p>
			SQLフィールドリストにフィールドIDと式のデータ型を示すフィールドクラスとSQL式を指定します。
			この画面で生成されたソースファイルは以下のようになります。
		</p>
		<div class="filecaption">任意のSQLフィールドの生成例</div>
		<div class="wrappre">
			<pre>
	/**
	 * コンストラクタ.
	 */
	public Test2Query() {
		this.setComment("SQLフィールドテスト");
		this.setDistinct(false);
		this.sampleTable = new SampleTable();
		this.sampleTable.setAlias("m");

		this.setFieldList(new FieldList(
			this.sampleTable.getSampleIdField()
			, this.sampleTable.getSampleTextField()
			, new SqlField(new NumericField("sampleNumeric2",10,2), "m.sample_numeric * 2")
		));
		this.setMainTable(sampleTable);

	}
			</pre>
		</div>
		<p>
			この問合せクラスのSQLは以下のようになります。
		</p>
		<div class="filecaption">上記問合せのSQL生成結果</div>
		<div class="wrappre">
			<pre>
select
m.sample_id as sample_id
,m.sample_text as sample_text
,m.sample_numeric * 2 as sample_numeric2
 from sample as  m
			</pre>
		</div>
	</body>
</html>